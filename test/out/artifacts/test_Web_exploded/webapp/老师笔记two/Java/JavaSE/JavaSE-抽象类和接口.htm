<!DOCTYPE HTML>
<!-- saved from url=(0079)http://172.13.19.31:6060/note_html/Java/JavaSE/1005010-JavaSE-抽象类和接口.html -->
<!DOCTYPE html PUBLIC "" ""><HTML><HEAD><META content="IE=11.0000" 
http-equiv="X-UA-Compatible">
 
<META http-equiv="Content-Type" content="text/html; charset=UTF-8"> 
<TITLE>JavaSE-抽象类和接口</TITLE> <LINK href="JavaSE-抽象类和接口_files/standalone.css" 
rel="stylesheet"> <LINK href="JavaSE-抽象类和接口_files/overlay-apple.css" rel="stylesheet"> 
<LINK href="JavaSE-抽象类和接口_files/article_edit.css" rel="stylesheet"> 
<STYLE type="text/css">
	#content{
		margin: 5px 10px;
	}
</STYLE>
	 <!-- 代码高亮 -->	 <LINK href="JavaSE-抽象类和接口_files/shCoreEclipse.css" rel="stylesheet">
	 <LINK href="JavaSE-抽象类和接口_files/my-highlighter.css" rel="stylesheet"> 
<META name="GENERATOR" content="MSHTML 11.00.10586.545"></HEAD> 
<BODY>
<DIV id="content">
<H1 align="center">JavaSE-抽象类和接口</H1>
<P align="right" 
style="margin: 0px 10px 0px 0px; padding: 0px;">最后修改时间：2016-06-08 12:06:40</P>
<HR style="border-width: 2px; border-color: lime;">

<H3>抽象类：用abstract关键字修饰的类</H3>
<UL>
  <LI>1).抽象类<FONT style="color: red;">不能实例化。即不能new ClassName();</FONT></LI>
  <LI>2).抽象类中<FONT style="color: red;">可以包含具体方法。</FONT></LI>
  <LI>3).<FONT 
  style="color: red;">子类继承父类(父类是抽象类)的情况下，那么该子类必须实现父类的所有抽象方法。否则，该子类也必须声明成抽象类。   
  </FONT></LI></UL>
<H3>抽象方法：用abstract关键字修饰的方法</H3>
<H4>示例</H4>
<PRE class="brush: java;">public class Test2{
	public static void main(String[] args){
//		AbsClass1 abs1 = new AbsClass1();//this is wrong compile Exception
		
		AbsClass1 abs2 = new AbsClass2();
		
		abs2.method();
		
	}
}


abstract class AbsClass1{
//	public abstract void method(){}//this is wrong  compile Exception
	public abstract void method();
}

class AbsClass2 extends AbsClass1{
	
	public void method(){
		System.out.println("abstract subClass running!");
	}
	
}
</PRE>
<UL>
  <LI><FONT style="color: red;">抽象方法定义在抽象类中。</FONT></LI>
  <LI><FONT 
  style="color: red;">如果一个类定义了抽象方法，那么这个类一定要声明成抽象类。(即该类一定是抽象类)</FONT></LI></UL>
<H3>接口：用interface关键字修饰的类</H3>
<H4>示例</H4>
<PRE class="brush: java;">public class Test3 {
	public static void main(String[] args){
		intClass1 int1 = new intImplClass();
		int1.method1();
		int1.method2();
	}
}

interface intClass1{//接口内的方法都是抽象的①和②是同样的效果
	
	public abstract void method1();//正确①
	
	public void method2();//正确②
	
}

/**
 * 如果一个类实现一个接口，并且该类有不是抽象类，那么该类必须实现接口的所有方法
 */
class intImplClass implements intClass1{
	public void method1(){
		System.out.println("mehod1 is running!");
	}
	
	public void method2(){
		System.out.println("mehod2 is running!");
	}
}

/**
 * 如果一个类实现一个接口，并不实现接口内所有方法，那么该类必须定义为抽象类
 * 如果这样实现接口，该抽象类也不可以实例化
 */
abstract class intImplClass1 implements intClass1{
	public void method1(){
		System.out.println("mehod1 is running!");
	}
}


interface intClass2{
	public void method3();
}

/**
 * 一个类可以实现多个接口，多个接口之间用","逗号分隔
 * 并且必须实现每个接口的所有方法
 */
class intImplClass2 implements intClass1,intClass2{

	@Override
	public void method3() {
		
	}

	@Override
	public void method1() {
		
	}

	@Override
	public void method2() {
		
	}
	
}
</PRE>
<UL>
  <LI><FONT style="color: red;">接口的地位等同于class。</FONT></LI>
  <LI><FONT style="color: red;">接口中的方法都是抽象方法。而且都是public的。</FONT></LI>
  <LI><FONT 
  style="color: red;">在声明接口中方法时，可以使用abstract关键字，也可以不使用(通常省略abstract)。</FONT></LI>
  <LI><FONT 
  style="color: red;">接口中的成员变量都是public、static、final的(通常这些关键字都不用写)。一般不在接口中定义属性。</FONT></LI>
  <LI>  接口可以看成是特殊的抽象类。   <FONT 
  style="color: red;">接口只能有抽象方法，不能有具体方法(每个方法都没有方法体)。</FONT>   </LI>
  <LI>类可以实现接口。   <FONT style="color: red;">实现用implements表示，代表某个类实现了接口。</FONT>   
  </LI>
  <LI><FONT style="color: red;">  
  如果一个类实现一个接口，并且该类有不是抽象类，那么该类必须实现接口的所有方法。否则该类应定义为抽象类。   </FONT>   </LI>
  <LI><FONT style="color: red;">  一个类可以实现多个接口，多个接口之间用","逗号分隔   </FONT></LI>
  <LI><FONT style="color: red;">接口的定义：成员变量都是常量（public static final）的，方法都是public 
  abstract的抽象类就是接口。</FONT></LI>
  <LI><FONT 
  style="color: red;">接口可以继承接口，而且接口的继承是可以多继承的。接口的继承也是使用extends关键字。<BR></FONT></LI></UL>
<H3>多态(polymorphic)：</H3>
<UL>
  <LI>父类型的引用可以指向子类的对象</LI>
  <LI>接口类型的引用可以指向实现该接口的类的实例</LI>
  <LI>关于接口与实现接口的类之间的强制类型转换方式与父类和子类之间的强制类型转换方式完全一样</LI></UL>
<H3>abstract的method是否可同时是static,是否可同时是native，是否可同时是synchronized?</H3>
<UL>
  <LI>abstract的method 不可以是static的，因为抽象的方法是要被子类实现的，而static与子类扯不上关系！</LI>
  <LI>native方法表示该方法要用另外一种依赖平台的编程语言实现的，不存在着被子类实现的问题，所以，它也不能是抽象的，不能与abstract混用。例如，FileOutputSteam类要硬件打交道，底层的实现用的是操作系统相关的api实现，例如，在windows用c语言实现的，所以，查看jdk 
  的源代码，可以发现FileOutputStream的open方法的定义如下：   private native void open(String name) 
  throws FileNotFoundException;   </LI>
  <LI>如果我们要用java调用别人写的c语言函数，我们是无法直接调用的，我们需要按照java的要求写一个c语言的函数，又我们的这个c语言函数去调用别人的c语言函数。由于我们的c语言函数是按java的要求来写的，我们这个c语言函数就可以与java对接上，java那边的对接方式就是定义出与我们这个c函数相对应的方法，java中对应的方法不需要写具体的代码，但需要在前面声明native。</LI>
  <LI>关于synchronized与abstract合用的问题，我觉得也不行，因为在我几年的学习和开发中，从来没见到过这种情况，并且我觉得synchronized应该是作用在一个具体的方法上才有意义。而且，方法上的synchronized同步所使用的同步锁对象是this，而抽象方法上无法确定this是什么。</LI></UL>
<HR style="border-width: 2px; border-color: lime;">

<DIV align="center">©copyright 版权所有   作者：zzy</DIV>
<SCRIPT src="../../pub/syntaxhighlighter/scripts/shCore.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="../../pub/syntaxhighlighter/scripts/shBrushJava.js" type="text/javascript"></SCRIPT>
	
<SCRIPT src="../../pub/syntaxhighlighter/scripts/shBrushJScript.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="../../pub/syntaxhighlighter/scripts/shBrushXml.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="../../pub/syntaxhighlighter/scripts/shBrushSql.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="../../pub/syntaxhighlighter/scripts/shBrushBash.js" type="text/javascript"></SCRIPT>
	
<SCRIPT src="../../pub/syntaxhighlighter/scripts/shBrushVb.js" type="text/javascript"></SCRIPT>
	
<SCRIPT src="../../pub/syntaxhighlighter/scripts/shBrushCss.js" type="text/javascript"></SCRIPT>
	
<SCRIPT src="../../pub/syntaxhighlighter/init.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="../../pub/js/jquery.tools.min.js" type="text/javascript"></SCRIPT>
 <!-- make all links with the 'rel' attribute open overlays --> 
<SCRIPT>
  $(function() {
      $("#apple img[rel]").overlay({effect: 'apple'});
    });
</SCRIPT>
 </DIV></BODY></HTML>
