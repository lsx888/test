<!DOCTYPE HTML>
<!-- saved from url=(0077)http://172.13.19.31:6060/note_html/Java/JavaSE/1006010-JavaSE-继承与多态.html -->
<!DOCTYPE html PUBLIC "" ""><HTML><HEAD><META content="IE=11.0000" 
http-equiv="X-UA-Compatible">
 
<META http-equiv="Content-Type" content="text/html; charset=UTF-8"> 
<TITLE>JavaSE-继承与多态</TITLE> <LINK href="JavaSE-继承与多态_files/standalone.css" rel="stylesheet"> 
<LINK href="JavaSE-继承与多态_files/overlay-apple.css" rel="stylesheet"> <LINK href="JavaSE-继承与多态_files/article_edit.css" 
rel="stylesheet"> 
<STYLE type="text/css">
	#content{
		margin: 5px 10px;
	}
</STYLE>
	 <!-- 代码高亮 -->	 <LINK href="JavaSE-继承与多态_files/shCoreEclipse.css" rel="stylesheet">
	 <LINK href="JavaSE-继承与多态_files/my-highlighter.css" rel="stylesheet"> 
<META name="GENERATOR" content="MSHTML 11.00.10586.545"></HEAD> 
<BODY>
<DIV id="content">
<H1 align="center">JavaSE-继承与多态</H1>
<P align="right" 
style="margin: 0px 10px 0px 0px; padding: 0px;">最后修改时间：2016-05-24 12:07:52</P>
<HR style="border-width: 2px; border-color: lime;">

<H3>继承：java是单继承的，表示一个类只能从另一个类继承(继承的类叫 子类，被继承的类叫父类)，java中继承 使用extends关键字</H3>
<UL>
  <LI>1).子类实例化的时候，默认首先调用父类的<FONT 
  style="color: red;">无参构造方法</FONT>，再执行子类的构造方法。</LI>
  <LI>2).如果父类没有无参构造方法时，应在子类的构造方法中第一行用super(参数);调用父类有参构造方法。</LI>
  <LI>3).子类实例化后，内存中就同时存在子类和父类的对象实例了。</LI>
  <LI><FONT style="color: red;">4).定义一个类的时候，如果没有显式的指定父类，  
  那么该类就继承于java.lang.Object类(JDK提供的类，Object是Java中所有类的直接或者间接父类)。</FONT>   </LI></UL>
<H3>关于继承：</H3>
<UL>
  <LI>1).父类有的，子类也有。(public、protected)</LI>
  <LI>2).父类没有的，子类也可以有。</LI>
  <LI>3).父类有的，子类可以改变。</LI>
  <LI>4).java是单继承的，类只有一个唯一的父类。</LI>
  <LI>5).一个类可以实现多个接口。</LI></UL>
<H3>关于继承的注意事项：</H3>
<UL>
  <LI>1).构造方法不能继承。</LI>
  <LI>2).方法和属性可以继承。</LI>
  <LI>3).子类的构造方法隐式的调用父类的无参构造方法。子类需要使用super()来显式调用父类的构造方法,super是指父类的引用</LI>
  <LI>4).super关键字必须放在子类构造方法的第一行</LI></UL>
<H3>多态(polymorphic)：</H3>
<UL>
  <LI>父类型的引用可以指向子类的对象</LI>
  <LI>子类就是父类(奔驰就是汽车)</LI></UL>
<H3><FONT style="color: red;">Parent p = new 
Child();当使用多态调用方法时，首先检查父类中是否有sing()方法；
 如果没有则编译错误，如果有，再去调用子类的该方法。要调用父类没有的方法，需要向下类型转换为子类再调用。 多态是运行期行为。 </FONT></H3>
<H4>示例</H4>
<PRE class="brush: java;">public class Test1{
	
	public static void main(String[] args){
		Parent p = new Child();
		p.say();
		
//		p.sing();//this is wrong compile Exception
		Child c = (Child)p;
		c.sing();
		
		Parent p2 = new Parent();
//		Child  c2 = (Child)p2;//Runtime Exception 		
	}
	
}


class Parent{
	
	public void say(){
		System.out.println("parent is say!");
	}
	
}

class Child extends Parent{
	public void say(){
		System.out.println("child is say!");
	}
	
	public void sing(){
		System.out.println("child is sing!");
	}
}
</PRE>
<H3>一共有两种强制类型转换：</H3>
<UL>
  <LI>1).向上类型转换：即将子类型转换为父类型，<FONT style="color: red;">不需要显式指定。</FONT></LI>
  <LI>2).向下类型转换：即将父类型转换为子类型，<FONT style="color: red;">必须需要显式转换。</FONT></LI></UL>
<HR style="border-width: 2px; border-color: lime;">

<DIV align="center">©copyright 版权所有   作者：zzy</DIV>
<SCRIPT src="../../pub/syntaxhighlighter/scripts/shCore.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="../../pub/syntaxhighlighter/scripts/shBrushJava.js" type="text/javascript"></SCRIPT>
	
<SCRIPT src="../../pub/syntaxhighlighter/scripts/shBrushJScript.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="../../pub/syntaxhighlighter/scripts/shBrushXml.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="../../pub/syntaxhighlighter/scripts/shBrushSql.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="../../pub/syntaxhighlighter/scripts/shBrushBash.js" type="text/javascript"></SCRIPT>
	
<SCRIPT src="../../pub/syntaxhighlighter/scripts/shBrushVb.js" type="text/javascript"></SCRIPT>
	
<SCRIPT src="../../pub/syntaxhighlighter/scripts/shBrushCss.js" type="text/javascript"></SCRIPT>
	
<SCRIPT src="../../pub/syntaxhighlighter/init.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="../../pub/js/jquery.tools.min.js" type="text/javascript"></SCRIPT>
 <!-- make all links with the 'rel' attribute open overlays --> 
<SCRIPT>
  $(function() {
      $("#apple img[rel]").overlay({effect: 'apple'});
    });
</SCRIPT>
 </DIV></BODY></HTML>
